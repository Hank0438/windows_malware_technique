#include <windows.h>
#include <stdio.h>
//#pragma comment(lib, "cmcfg32.lib")

BOOL EnablePrivilege()
{
    LUID PrivilegeRequired;
    DWORD dwLen = 0, iCount = 0;
    BOOL bRes = FALSE;
    HANDLE hToken = NULL;
    BYTE* pBuffer = NULL;
    TOKEN_PRIVILEGES* pPrivs = NULL;

    bRes = LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &PrivilegeRequired);
    if (!bRes) return FALSE;

    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken);
    if (!bRes) return FALSE;

    bRes = GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &dwLen);
    if (TRUE == bRes)
    {
        CloseHandle(hToken);
        return FALSE;
    }
    pBuffer = (BYTE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLen);
    if (NULL == pBuffer) return FALSE;

    if (!GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, &dwLen))
    {
        CloseHandle(hToken);
        HeapFree(GetProcessHeap(), 0, pBuffer);
        return FALSE;
    }

    // Iterate through all the privileges and enable the one required
    bRes = FALSE;
    pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for (iCount = 0; iCount < pPrivs->PrivilegeCount; iCount++)
    {
        if (pPrivs->Privileges[iCount].Luid.LowPart == PrivilegeRequired.LowPart &&
            pPrivs->Privileges[iCount].Luid.HighPart == PrivilegeRequired.HighPart)
        {
            pPrivs->Privileges[iCount].Attributes |= SE_PRIVILEGE_ENABLED;
            // here it's found
            bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, dwLen, NULL, NULL);
            break;
        }
    }

    CloseHandle(hToken);
    HeapFree(GetProcessHeap(), 0, pBuffer);
    return bRes;
}

BOOL CheckAndEnablePrivilege(HANDLE hTokenToCheck, LPCWSTR pwszPrivilegeToCheck)
{
    BOOL bResult = FALSE;
    HANDLE hToken = INVALID_HANDLE_VALUE;

    DWORD dwTokenPrivilegesSize = 0;
    PTOKEN_PRIVILEGES pTokenPrivileges = NULL;

    LPWSTR pwszPrivilegeName = NULL;

    if (hTokenToCheck)
    {
        // If a token handle was supplied, check this token
        hToken = hTokenToCheck;
    }
    else
    {
        // If a token handle wasn't supplied, check the token of the current process
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken))
        {
            wprintf(L"OpenProcessToken() failed. Error: %d\n", GetLastError());
            goto cleanup;
        }
    }

    if (!GetTokenInformation(hToken, TokenPrivileges, NULL, dwTokenPrivilegesSize, &dwTokenPrivilegesSize))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            wprintf(L"GetTokenInformation() failed. Error: %d\n", GetLastError());
            goto cleanup;
        }
    }

    pTokenPrivileges = (PTOKEN_PRIVILEGES)malloc(dwTokenPrivilegesSize);
    if (!pTokenPrivileges)
        goto cleanup;

    if (!GetTokenInformation(hToken, TokenPrivileges, pTokenPrivileges, dwTokenPrivilegesSize, &dwTokenPrivilegesSize))
    {
        wprintf(L"GetTokenInformation() failed. Error: %d\n", GetLastError());
        goto cleanup;
    }

    for (DWORD i = 0; i < pTokenPrivileges->PrivilegeCount; i++)
    {
        LUID_AND_ATTRIBUTES laa = pTokenPrivileges->Privileges[i];
        DWORD dwPrivilegeNameLength = 0;

        if (!LookupPrivilegeName(NULL, &(laa.Luid), NULL, &dwPrivilegeNameLength))
        {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            {
                wprintf(L"LookupPrivilegeName() failed. Error: %d\n", GetLastError());
                goto cleanup;
            }
        }

        dwPrivilegeNameLength++;
        pwszPrivilegeName = (LPWSTR)malloc(dwPrivilegeNameLength * sizeof(WCHAR));
        if (!pwszPrivilegeName)
            goto cleanup;

        if (!LookupPrivilegeName(NULL, &(laa.Luid), pwszPrivilegeName, &dwPrivilegeNameLength))
        {
            wprintf(L"LookupPrivilegeName() failed. Error: %d\n", GetLastError());
            goto cleanup;
        }

        if (!_wcsicmp(pwszPrivilegeName, pwszPrivilegeToCheck))
        {
            TOKEN_PRIVILEGES tp = { 0 };

            ZeroMemory(&tp, sizeof(TOKEN_PRIVILEGES));
            tp.PrivilegeCount = 1;
            tp.Privileges[0].Luid = laa.Luid;
            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL))
            {
                wprintf(L"AdjustTokenPrivileges() failed. Error: %d\n", GetLastError());
                goto cleanup;
            }

            bResult = TRUE;
        }

        free(pwszPrivilegeName);

        if (bResult)
            break;
    }

cleanup:
    if (hToken)
        CloseHandle(hToken);
    if (pTokenPrivileges)
        free(pTokenPrivileges);

    return bResult;
}

int enablePriv() {
    HANDLE hToken;
    LPCTSTR lpszPrivilege = SE_TCB_NAME;
    BOOL bEnablePrivilege = TRUE;
    BOOL bRes = FALSE;

    bRes = ImpersonateSelf(SecurityImpersonation);
    if (!bRes) return -1;

    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hToken);
    if (!bRes) return -1;


    TOKEN_PRIVILEGES tp;
    LUID luid;

    if (!LookupPrivilegeValue(
        NULL,            // lookup privilege on local system
        lpszPrivilege,   // privilege to lookup 
        &luid))        // receives LUID of privilege
    {
        printf("LookupPrivilegeValue error: %u\n", GetLastError());
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    // Enable the privilege or disable all privileges.

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL))
    {
        printf("AdjustTokenPrivileges error: %u\n", GetLastError());
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)

    {
        printf("The token does not have the specified privilege. \n");
    }
    return 0;
}

int main() {
    //EnablePrivilege();
    //ShellExecuteA(NULL, "open", "cmd", "", NULL, SW_NORMAL);  // fork ?
                                                         
    if (!CheckAndEnablePrivilege(NULL, SE_BACKUP_NAME))
    {
        wprintf(L"[-] A privilege is missing: '%ws'\n", SE_BACKUP_NAME);
    }
   
    

    //WinExec("cmd", 0);   // fork ?
    //while (1);

    return 0;
}